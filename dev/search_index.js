var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ExproniconLite","category":"page"},{"location":"#ExproniconLite","page":"Home","title":"ExproniconLite","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ExproniconLite]","category":"page"},{"location":"#ExproniconLite.no_default","page":"Home","title":"ExproniconLite.no_default","text":"const no_default = NoDefault()\n\nConstant instance for NoDefault that describes a field should have no default value.\n\n\n\n\n\n","category":"constant"},{"location":"#ExproniconLite.JLExpr","page":"Home","title":"ExproniconLite.JLExpr","text":"abstract type JLExpr end\n\nAbstract type for Julia syntax type.\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLField","page":"Home","title":"ExproniconLite.JLField","text":"JLField <: JLExpr\n\nType describes a Julia field in a Julia struct.\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLField-Tuple{}","page":"Home","title":"ExproniconLite.JLField","text":"JLField(;name, type=Any, doc=nothing, line=nothing)\n\nCreate a JLField instance.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLFor","page":"Home","title":"ExproniconLite.JLFor","text":"JLFor <: JLExpr\n\nSyntax type for Julia for loop.\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLFor-Tuple{Expr}","page":"Home","title":"ExproniconLite.JLFor","text":"JLFor(ex::Expr)\n\nCreate a JLFor from given Julia for loop expression.\n\nExample\n\njulia> ex = @expr for i in 1:10, j in 1:j\n           M[i, j] += 1\n       end\n:(for i = 1:10, j = 1:j\n      #= REPL[3]:2 =#\n      M[i, j] += 1\n  end)\n\njulia> jl = JLFor(ex)\nfor i in 1 : 10,\n    j in 1 : j\n    #= loop body =#\n    begin\n        #= REPL[3]:2 =#        \n        M[i, j] += 1        \n    end\nend\n\njulia> jl.vars\n2-element Vector{Any}:\n :i\n :j\n\njulia> jl.iterators\n2-element Vector{Any}:\n :(1:10)\n :(1:j)\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLFor-Tuple{}","page":"Home","title":"ExproniconLite.JLFor","text":"JLFor(;vars=[], iterators=[], kernel=nothing)\n\nGenerate a JLFor object.\n\nKwargs\n\nvars: loop variables.\niterators: loop iterators.\nkernel: loop kernel.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLFunction","page":"Home","title":"ExproniconLite.JLFunction","text":"JLFunction <: JLExpr\n\nType describes a Julia function declaration expression.\n\nExample\n\nConstruct a function expression\n\njulia> JLFunction(;name=:foo, args=[:(x::T)], body= quote 1+1 end, head=:function, whereparams=[:T])\nfunction foo(x::T) where {T}\n    #= REPL[25]:1 =#    \n    1 + 1    \nend\n\nDecompose a function expression\n\njulia> ex = :(function foo(x::T) where {T}\n           #= REPL[25]:1 =#    \n           1 + 1    \n       end)\n:(function foo(x::T) where T\n      #= REPL[26]:1 =#\n      #= REPL[26]:3 =#\n      1 + 1\n  end)\n\njulia> jl = JLFunction(ex)\nfunction foo(x::T) where {T}\n    #= REPL[26]:1 =#    \n    #= REPL[26]:3 =#    \n    1 + 1    \nend\n\nGenerate Expr from JLFunction\n\njulia> codegen_ast(jl)\n:(function foo(x::T) where T\n      #= REPL[26]:1 =#\n      #= REPL[26]:3 =#\n      1 + 1\n  end)\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLFunction-Tuple{Expr}","page":"Home","title":"ExproniconLite.JLFunction","text":"JLFunction(ex::Expr)\n\nCreate a JLFunction object from a Julia function Expr.\n\nExample\n\njulia> JLFunction(:(f(x) = 2))\nf(x) = begin\n    #= REPL[37]:1 =#    \n    2    \nend\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLIfElse","page":"Home","title":"ExproniconLite.JLIfElse","text":"JLIfElse <: JLExpr\n\nJLIfElse describes a Julia if ... elseif ... else ... end expression. It allows one to easily construct such expression by inserting condition and code block via a map.\n\nExample\n\nConstruct JLIfElse object\n\nOne can construct an ifelse as following\n\njulia> jl = JLIfElse()\nnothing\n\njulia> jl.map[:(foo(x))] = :(x = 1 + 1)\n:(x = 1 + 1)\n\njulia> jl.map[:(goo(x))] = :(y = 1 + 2)\n:(y = 1 + 2)\n\njulia> jl.otherwise = :(error(\"abc\"))\n:(error(\"abc\"))\n\njulia> jl\nif foo(x)\n    x = 1 + 1\nelseif goo(x)\n    y = 1 + 2\nelse\n    error(\"abc\")\nend\n\nGenerate the Julia Expr object\n\nto generate the corresponding Expr object, one can call codegen_ast.\n\njulia> codegen_ast(jl)\n:(if foo(x)\n      x = 1 + 1\n  elseif goo(x)\n      y = 1 + 2\n  else\n      error(\"abc\")\n  end)\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLIfElse-Tuple{Expr}","page":"Home","title":"ExproniconLite.JLIfElse","text":"JLIfElse(ex::Expr)\n\nCreate a JLIfElse from given Julia ifelse Expr.\n\nExample\n\njulia> ex = :(if foo(x)\n             x = 1 + 1\n         elseif goo(x)\n             y = 1 + 2\n         else\n             error(\"abc\")\n         end)\n:(if foo(x)\n      #= REPL[41]:2 =#\n      x = 1 + 1\n  elseif #= REPL[41]:3 =# goo(x)\n      #= REPL[41]:4 =#\n      y = 1 + 2\n  else\n      #= REPL[41]:6 =#\n      error(\"abc\")\n  end)\n\njulia> JLIfElse(ex)\nif foo(x)\n    begin\n        #= REPL[41]:2 =#        \n        x = 1 + 1        \n    end\nelseif begin\n    #= REPL[41]:3 =#    \n    goo(x)    \nend\n    begin\n        #= REPL[41]:4 =#        \n        y = 1 + 2        \n    end\nelse\n    begin\n        #= REPL[41]:6 =#        \n        error(\"abc\")        \n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLIfElse-Tuple{}","page":"Home","title":"ExproniconLite.JLIfElse","text":"JLIfElse()\n\nCreate an emptry ifelse syntax type instance.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLKwField","page":"Home","title":"ExproniconLite.JLKwField","text":"JLKwField <: JLExpr\n\nType describes a Julia field that can have a default value in a Julia struct.\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLKwField-Tuple{}","page":"Home","title":"ExproniconLite.JLKwField","text":"JLKwField(;name, type=Any, doc=nothing, line=nothing, default=no_default)\n\nCreate a JLKwField instance.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLKwStruct","page":"Home","title":"ExproniconLite.JLKwStruct","text":"JLKwStruct <: JLExpr\n\nType describes a Julia struct that allows keyword definition of defaults.\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLKwStruct-2","page":"Home","title":"ExproniconLite.JLKwStruct","text":"JLKwStruct(ex::Expr, typealias=nothing)\n\nCreate a JLKwStruct from given Julia struct Expr, with an option to attach an alias to this type name.\n\nExample\n\njulia> JLKwStruct(:(struct Foo\n           x::Int = 1\n       end))\n#= kw =# struct Foo\n    #= REPL[39]:2 =#\n    x::Int = 1\nend\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLKwStruct-Tuple{}","page":"Home","title":"ExproniconLite.JLKwStruct","text":"JLKwStruct(;kw...)\n\nCreate a JLKwStruct instance.\n\nKwargs\n\nname: required struct name.\ntypealias: alias to the struct.\nismutable: if it is a mutable struct.\ntypevars: type variables.\nsupertype: supertype of the struct.\nfields: fields of the struct, must be in type JLKwField.\nconstructors: constructors of the struct, must be in type JLFunction.\nline: LineNumberNode of the struct.\ndoc: doc string of the struct.\nmisc: other expressions inside the struct expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLStruct","page":"Home","title":"ExproniconLite.JLStruct","text":"JLStruct <: JLExpr\n\nType describes a Julia struct.\n\nExample\n\nConstruct a Julia struct.\n\njulia> JLStruct(;name=:Foo, typevars=[:T], fields=[JLField(;name=:x, type=Int)])\nstruct Foo{T}\n    x::Int64\nend\n\nDecompose a Julia struct expression\n\njulia> ex = :(struct Foo{T}\n           x::Int64\n       end)\n:(struct Foo{T}\n      #= REPL[31]:2 =#\n      x::Int64\n  end)\n\njulia> jl = JLStruct(ex)\nstruct Foo{T}\n    #= REPL[31]:2 =#\n    x::Int64\nend\n\nGenerate a Julia struct expression\n\njulia> codegen_ast(jl)\n:(struct Foo{T}\n      #= REPL[31]:2 =#\n      x::Int64\n  end)\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.JLStruct-Tuple{Expr}","page":"Home","title":"ExproniconLite.JLStruct","text":"JLStruct(ex::Expr)\n\nCreate a JLStruct object from a Julia struct Expr.\n\nExample\n\njulia> JLStruct(:(struct Foo\n           x::Int\n       end))\nstruct Foo\n    #= REPL[38]:2 =#\n    x::Int\nend\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.JLStruct-Tuple{}","page":"Home","title":"ExproniconLite.JLStruct","text":"JLStruct(;kw...)\n\nCreate a JLStruct instance.\n\nKwargs\n\nname: required struct name.\nismutable: if it is a mutable struct.\ntypevars: type variables.\nsupertype: supertype of the struct.\nfields: fields of the struct, must be in type JLField.\nconstructors: constructors of the struct, must be in type JLFunction.\nline: LineNumberNode of the struct.\ndoc: doc string of the struct.\nmisc: other expressions inside the struct expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.NoDefault","page":"Home","title":"ExproniconLite.NoDefault","text":"NoDefault\n\nType describes a field should have no default value.\n\n\n\n\n\n","category":"type"},{"location":"#ExproniconLite.codegen_ast-Tuple{Any}","page":"Home","title":"ExproniconLite.codegen_ast","text":"codegen_ast(def)\n\nGenerate Julia AST object Expr from a given syntax type.\n\nExample\n\nOne can generate the Julia AST object from a JLKwStruct syntax type.\n\njulia> def = @expr JLKwStruct struct Foo{N, T}\n                  x::T = 1\n              end\n#= kw =# struct Foo{N, T}\n    #= REPL[19]:2 =#\n    x::T = 1\nend\n\njulia> codegen_ast(def)|>rm_lineinfo\nquote\n    struct Foo{N, T}\n        x::T\n    end\n    begin\n        function Foo{N, T}(; x = 1) where {N, T}\n            Foo{N, T}(x)\n        end\n        function Foo{N}(; x::T = 1) where {N, T}\n            Foo{N, T}(x)\n        end\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.codegen_ast_fields-Tuple{Any}","page":"Home","title":"ExproniconLite.codegen_ast_fields","text":"codegen_ast_fields(fields; just_name::Bool=true)\n\nGenerate a list of Julia AST object for each field, only generate a list of field names by default, option just_name can be turned off to call codegen_ast on each field object.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.codegen_ast_kwfn","page":"Home","title":"ExproniconLite.codegen_ast_kwfn","text":"codegen_ast_kwfn(def[, name = nothing])\n\nGenerate the keyword function from a Julia struct definition.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, T}\n                  x::T = 1\n              end\n#= kw =# struct Foo{N, T}\n    #= REPL[19]:2 =#\n    x::T = 1\nend\n\njulia> codegen_ast_kwfn(def)|>prettify\nquote\n    function Foo{N, T}(; x = 1) where {N, T}\n        Foo{N, T}(x)\n    end\n    function Foo{N}(; x::T = 1) where {N, T}\n        Foo{N, T}(x)\n    end\nend\n\njulia> def = @expr JLKwStruct struct Foo\n                  x::Int = 1\n              end\n#= kw =# struct Foo\n    #= REPL[23]:2 =#\n    x::Int = 1\nend\n\njulia> codegen_ast_kwfn(def)|>prettify\nquote\n    function Foo(; x = 1)\n        Foo(x)\n    end\n    nothing\nend\n\n\n\n\n\n","category":"function"},{"location":"#ExproniconLite.codegen_ast_kwfn_infer","page":"Home","title":"ExproniconLite.codegen_ast_kwfn_infer","text":"codegen_ast_kwfn_infer(def, name = nothing)\n\nGenerate the keyword function that infers the type.\n\n\n\n\n\n","category":"function"},{"location":"#ExproniconLite.codegen_ast_kwfn_plain","page":"Home","title":"ExproniconLite.codegen_ast_kwfn_plain","text":"codegen_ast_kwfn_plain(def[, name = nothing])\n\nGenerate the plain keyword function that does not infer type variables. So that one can use the type conversions defined by constructors.\n\n\n\n\n\n","category":"function"},{"location":"#ExproniconLite.codegen_ast_struct-Tuple{Any}","page":"Home","title":"ExproniconLite.codegen_ast_struct","text":"codegen_ast_struct(def)\n\nGenerate pure Julia struct Expr from struct definition. This is equivalent to codegen_ast for JLStruct. See also codegen_ast.\n\nExample\n\njulia> def = JLKwStruct(:(struct Foo\n           x::Int=1\n           \n           Foo(x::Int) = new(x)\n       end))\nstruct Foo\n    x::Int = 1\nend\n\njulia> codegen_ast_struct(def)\n:(struct Foo\n      #= REPL[21]:2 =#\n      x::Int\n      Foo(x::Int) = begin\n              #= REPL[21]:4 =#\n              new(x)\n          end\n  end)\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.codegen_ast_struct_body-Tuple{Any}","page":"Home","title":"ExproniconLite.codegen_ast_struct_body","text":"codegen_ast_struct_body(def)\n\nGenerate the struct body.\n\nExample\n\njulia> def = JLStruct(:(struct Foo\n           x::Int\n           \n           Foo(x::Int) = new(x)\n       end))\nstruct Foo\n    x::Int\nend\n\njulia> codegen_ast_struct_body(def)\nquote\n    #= REPL[15]:2 =#\n    x::Int\n    Foo(x::Int) = begin\n            #= REPL[15]:4 =#\n            new(x)\n        end\nend\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.codegen_ast_struct_head-Tuple{Any}","page":"Home","title":"ExproniconLite.codegen_ast_struct_head","text":"codegen_ast_struct_head(def)\n\nGenerate the struct head.\n\nExample\n\njulia> using Expronicon\n\njulia> def = JLStruct(:(struct Foo{T} end))\nstruct Foo{T}\nend\n\njulia> codegen_ast_struct_head(def)\n:(Foo{T})\n\njulia> def = JLStruct(:(struct Foo{T} <: AbstractArray end))\nstruct Foo{T} <: AbstractArray\nend\n\njulia> codegen_ast_struct_head(def)\n:(Foo{T} <: AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.compare_expr-Tuple{Any, Any}","page":"Home","title":"ExproniconLite.compare_expr","text":"compare_expr(lhs, rhs)\n\nCompare two expression of type Expr or Symbol semantically, which:\n\nignore the detail value LineNumberNode in comparision\nignore the detailed name of typevars in Expr(:curly, ...) or Expr(:where, ...)\n\nThis gives a way to compare two Julia expression semantically which means although some details of the expression is different but they should produce the same lowered code.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.compare_vars-Tuple{Any, Any}","page":"Home","title":"ExproniconLite.compare_vars","text":"compare_vars(lhs, rhs)\n\nCompare two expression by assuming all Symbols are variables, thus their value doesn't matter, only where they are matters under this assumption. See also compare_expr.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.eval_interp-Tuple{Module, Any}","page":"Home","title":"ExproniconLite.eval_interp","text":"eval_interp(m::Module, ex)\n\nevaluate the interpolation operator in ex inside given module m.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.eval_literal-Tuple{Module, Any}","page":"Home","title":"ExproniconLite.eval_literal","text":"eval_literal(m::Module, ex)\n\nEvaluate the literal values and insert them back to the expression. The literal value can be checked via is_literal.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.flatten_blocks-Tuple{Any}","page":"Home","title":"ExproniconLite.flatten_blocks","text":"flatten_blocks(ex)\n\nRemove hierachical expression blocks.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.has_kwfn_constructor","page":"Home","title":"ExproniconLite.has_kwfn_constructor","text":"has_kwfn_constructor(def[, name = struct_name_plain(def)])\n\nCheck if the struct definition contains keyword function constructor of name. The constructor name to check by default is the plain constructor which does not infer any type variables and requires user to input all type variables. See also struct_name_plain.\n\n\n\n\n\n","category":"function"},{"location":"#ExproniconLite.has_plain_constructor","page":"Home","title":"ExproniconLite.has_plain_constructor","text":"has_plain_constructor(def, name = struct_name_plain(def))\n\nCheck if the struct definition contains the plain constructor of name. By default the name is the inferable name struct_name_plain.\n\nExample\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::Int\n    y::N\n\n    Foo{T, N}(x, y) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # true\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo(x, y) = new{typeof(x), typeof(y)}(x, y)\nend\n\nhas_plain_constructor(def) # false\n\nthe arguments must have no type annotations.\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo{T, N}(x::T, y::N) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # false\n\n\n\n\n\n","category":"function"},{"location":"#ExproniconLite.is_field-Tuple{Any}","page":"Home","title":"ExproniconLite.is_field","text":"is_field(ex)\n\nCheck if ex is a valid field expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.is_field_default-Tuple{Any}","page":"Home","title":"ExproniconLite.is_field_default","text":"is_field_default(ex)\n\nCheck if ex is a <field expr> = <default expr> expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.is_for-Tuple{Any}","page":"Home","title":"ExproniconLite.is_for","text":"is_for(ex)\n\nCheck if ex is a for loop expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.is_function-Tuple{Any}","page":"Home","title":"ExproniconLite.is_function","text":"is_function(def)\n\nCheck if given object is a function expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.is_ifelse-Tuple{Any}","page":"Home","title":"ExproniconLite.is_ifelse","text":"is_ifelse(ex)\n\nCheck if ex is an if ... elseif ... else ... end expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.is_kw_function-Tuple{Any}","page":"Home","title":"ExproniconLite.is_kw_function","text":"is_kw_function(def)\n\nCheck if a given function definition supports keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.is_literal-Tuple{Any}","page":"Home","title":"ExproniconLite.is_literal","text":"is_literal(x)\n\nCheck if x is a literal value.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.is_struct-Tuple{Any}","page":"Home","title":"ExproniconLite.is_struct","text":"is_struct(ex)\n\nCheck if ex is a struct expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.is_struct_not_kw_struct-Tuple{Any}","page":"Home","title":"ExproniconLite.is_struct_not_kw_struct","text":"is_struct_not_kw_struct(ex)\n\nCheck if ex is a struct expression excluding keyword struct syntax.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.name_only-Tuple{Any}","page":"Home","title":"ExproniconLite.name_only","text":"name_only(ex)\n\nRemove everything else leaving just names, currently supports function calls, type with type variables, subtype operator <: and type annotation ::.\n\nExample\n\njulia> using Expronicon\n\njulia> name_only(:(sin(2)))\n:sin\n\njulia> name_only(:(Foo{Int}))\n:Foo\n\njulia> name_only(:(Foo{Int} <: Real))\n:Foo\n\njulia> name_only(:(x::Int))\n:x\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.prettify-Tuple{Any}","page":"Home","title":"ExproniconLite.prettify","text":"prettify(ex)\n\nPrettify given expression, remove all LineNumberNode and extra code blocks.\n\ntips: Tips\nthe LineNumberNode inside macro calls won't be removed since the macrocall expression requires a LineNumberNode. See also issues/#9.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.rm_annotations-Tuple{Any}","page":"Home","title":"ExproniconLite.rm_annotations","text":"rm_annotations(x)\n\nRemove type annotation of given expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.rm_lineinfo-Tuple{Any}","page":"Home","title":"ExproniconLite.rm_lineinfo","text":"rm_lineinfo(ex)\n\nRemove LineNumberNode in a given expression.\n\ntips: Tips\nthe LineNumberNode inside macro calls won't be removed since the macrocall expression requires a LineNumberNode. See also issues/#9.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.rm_nothing-Tuple{Any}","page":"Home","title":"ExproniconLite.rm_nothing","text":"rm_nothing(ex)\n\nRemove the constant value nothing in given expression ex.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.split_doc-Tuple{Expr}","page":"Home","title":"ExproniconLite.split_doc","text":"split_doc(ex::Expr) -> line, doc, expr\n\nSplit doc string from given expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.split_function-Tuple{Expr}","page":"Home","title":"ExproniconLite.split_function","text":"split_function(ex::Expr) -> head, call, body\n\nSplit function head declaration with function body.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.split_function_head-Tuple{Expr}","page":"Home","title":"ExproniconLite.split_function_head","text":"split_function_head(ex::Expr) -> name, args, kw, whereparams\n\nSplit function head to name, arguments, keyword arguments and where parameters.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.split_struct-Tuple{Expr}","page":"Home","title":"ExproniconLite.split_struct","text":"split_struct(ex::Expr) -> ismutable, name, typevars, supertype, body\n\nSplit struct definition head and body.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.split_struct_name-Tuple{Any}","page":"Home","title":"ExproniconLite.split_struct_name","text":"split_struct_name(ex::Expr) -> name, typevars, supertype\n\nSplit the name, type parameters and supertype definition from struct declaration head.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.struct_name_plain-Tuple{Any}","page":"Home","title":"ExproniconLite.struct_name_plain","text":"struct_name_plain(def)\n\nPlain constructor name. See also struct_name_without_inferable.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, Inferable}\n    x::Inferable = 1\nend\n\njulia> struct_name_plain(def)\n:(Foo{N, Inferable})\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.struct_name_without_inferable-Tuple{Any}","page":"Home","title":"ExproniconLite.struct_name_without_inferable","text":"struct_name_without_inferable(def; leading_inferable::Bool=true)\n\nConstructor name that assume some of the type variables is inferred. See also struct_name_plain. The kwarg leading_inferable can be used to configure whether to preserve the leading inferable type variables, the default is true to be consistent with the default julia constructors.\n\nExample\n\njulia> def = @expr JLKwStruct struct Foo{N, Inferable}\n    x::Inferable = 1\nend\n\njulia> struct_name_without_inferable(def)\n:(Foo{N})\n\njulia> def = @expr JLKwStruct struct Foo{Inferable, NotInferable}\n    x::Inferable\nend\n\njulia> struct_name_without_inferable(def; leading_inferable=true)\n:(Foo{Inferable, NotInferable})\n\njulia> struct_name_without_inferable(def; leading_inferable=false)\n:(Foo{NotInferable})\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.subtitute-Tuple{Expr, Pair}","page":"Home","title":"ExproniconLite.subtitute","text":"subtitute(ex::Expr, old=>new)\n\nSubtitute the old symbol old with new.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.support_default-Tuple{Any}","page":"Home","title":"ExproniconLite.support_default","text":"support_default(f)\n\nCheck if field type f supports default value.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xcall-Tuple{Any, Vararg{Any, N} where N}","page":"Home","title":"ExproniconLite.xcall","text":"xcall(name, args...; kw...)\n\nCreate a function call to name.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xcall-Tuple{Module, Symbol, Vararg{Any, N} where N}","page":"Home","title":"ExproniconLite.xcall","text":"xcall(m::Module, name::Symbol, args...; kw...)\n\nCreate a function call to GlobalRef(m, name).\n\ntip: Tip\ndue to Revise/#616, to make your macro work with Revise, use the dot expression Expr(:., <module>, QuoteNode(<name>)) instead of GlobalRef.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xfirst-Tuple{Any}","page":"Home","title":"ExproniconLite.xfirst","text":"xfirst(collection)\n\nCreate a function call expression to Base.first.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xiterate-Tuple{Any, Any}","page":"Home","title":"ExproniconLite.xiterate","text":"xiterate(it, st)\n\nCreate a function call expression to Base.iterate.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xiterate-Tuple{Any}","page":"Home","title":"ExproniconLite.xiterate","text":"xiterate(it)\n\nCreate a function call expression to Base.iterate.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xlast-Tuple{Any}","page":"Home","title":"ExproniconLite.xlast","text":"xlast(collection)\n\nCreate a function call expression to Base.last.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xmap-Tuple{Any, Vararg{Any, N} where N}","page":"Home","title":"ExproniconLite.xmap","text":"xmap(f, xs...)\n\nCreate a function call expression to Base.map.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xmapreduce-Tuple{Any, Any, Vararg{Any, N} where N}","page":"Home","title":"ExproniconLite.xmapreduce","text":"xmapreduce(f, op, xs...)\n\nCreate a function call expression to Base.mapreduce.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xnamedtuple-Tuple{}","page":"Home","title":"ExproniconLite.xnamedtuple","text":"xnamedtuple(;kw...)\n\nCreate a NamedTuple expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xprint-Tuple","page":"Home","title":"ExproniconLite.xprint","text":"xprint(xs...)\n\nCreate a function call expression to Base.print.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xprintln-Tuple","page":"Home","title":"ExproniconLite.xprintln","text":"xprintln(xs...)\n\nCreate a function call expression to Base.println.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xpush-Tuple{Any, Vararg{Any, N} where N}","page":"Home","title":"ExproniconLite.xpush","text":"xpush(collection, items...)\n\nCreate a function call expression to Base.push!.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.xtuple-Tuple","page":"Home","title":"ExproniconLite.xtuple","text":"xtuple(xs...)\n\nCreate a Tuple expression.\n\n\n\n\n\n","category":"method"},{"location":"#ExproniconLite.@expr-Tuple{Any, Any}","page":"Home","title":"ExproniconLite.@expr","text":"@expr <type> <expression>\n\nReturn the expression in given type.\n\nExample\n\njulia> ex = @expr JLKwStruct struct Foo{N, T}\n           x::T = 1\n       end\n#= kw =# struct Foo{N, T}\n    #= /home/roger/code/julia/Expronicon/test/analysis.jl:5 =#\n    x::T = 1\nend\n\n\n\n\n\n","category":"macro"},{"location":"#ExproniconLite.@expr-Tuple{Any}","page":"Home","title":"ExproniconLite.@expr","text":"@expr <expression>\n\nReturn the original expression object.\n\nExample\n\njulia> ex = @expr x + 1\n:(x + 1)\n\n\n\n\n\n","category":"macro"},{"location":"#ExproniconLite.@test_expr-Tuple{Any, Any}","page":"Home","title":"ExproniconLite.@test_expr","text":"@test_expr <type> <ex>\n\nTest if the syntax type generates the same expression ex. Returns the corresponding syntax type instance. Requires using Test before using this macro.\n\nExample\n\ndef = @test_expr JLFunction function (x, y)\n    return 2\nend\n@test is_kw_fn(def) == false\n\n\n\n\n\n","category":"macro"},{"location":"#ExproniconLite.@test_expr-Tuple{Expr}","page":"Home","title":"ExproniconLite.@test_expr","text":"@test_expr <expr> == <expr>\n\nTest if two expression is equivalent semantically, this uses compare_expr to decide if they are equivalent, ignores things such as LineNumberNode generated Symbol in Expr(:curly, ...) or Expr(:where, ...).\n\n\n\n\n\n","category":"macro"}]
}
