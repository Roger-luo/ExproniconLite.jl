
    #= none:1 =# Core.@doc "    is_valid_typevar(typevar)\n\nCheck if the given typevar is a valid typevar.\n\n!!! note\n    This function is based on [this discourse post](https://discourse.julialang.org/t/what-are-valid-type-parameters/471).\n" function is_valid_typevar(typevar)
            let
                true
                var"##return#312" = nothing
                var"##314" = typevar
                if var"##314" isa TypeVar
                    begin
                        var"##return#312" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#313#315")))
                    end
                end
                if var"##314" isa Type
                    begin
                        var"##return#312" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#313#315")))
                    end
                end
                if var"##314" isa QuoteNode
                    begin
                        var"##return#312" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#313#315")))
                    end
                end
                if isbitstype(typeof(typevar))
                    var"##return#312" = let
                            true
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#313#315")))
                end
                if var"##314" isa Tuple
                    var"##return#312" = let
                            all((x->begin
                                        x isa Symbol || isbitstype(typeof(x))
                                    end), typevar)
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#313#315")))
                end
                begin
                    var"##return#312" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#313#315")))
                end
                error("matching non-exhaustive, at #= none:10 =#")
                $(Expr(:symboliclabel, Symbol("####final#313#315")))
                var"##return#312"
            end
        end
    #= none:20 =# Core.@doc "    is_literal(x)\n\nCheck if `x` is a literal value.\n" function is_literal(x)
            !(x isa Expr || (x isa Symbol || x isa GlobalRef))
        end
    #= none:29 =# Core.@doc "    is_tuple(ex)\n\nCheck if `ex` is a tuple expression, i.e. `:((a,b,c))`\n" is_tuple(x) = begin
                Meta.isexpr(x, :tuple)
            end
    #= none:36 =# Core.@doc "    is_splat(ex)\n\nCheck if `ex` is a splat expression, i.e. `:(f(x)...)`\n" is_splat(x) = begin
                Meta.isexpr(x, :...)
            end
    #= none:43 =# Core.@doc "    is_gensym(s)\n\nCheck if `s` is generated by `gensym`.\n\n!!! note\n    Borrowed from [MacroTools](https://github.com/FluxML/MacroTools.jl).\n" is_gensym(s::Symbol) = begin
                occursin("#", string(s))
            end
    is_gensym(s) = begin
            false
        end
    #= none:54 =# Core.@doc "    support_default(f)\n\nCheck if field type `f` supports default value.\n" support_default(f) = begin
                false
            end
    support_default(f::JLKwField) = begin
            true
        end
    #= none:62 =# Core.@doc "    has_symbol(ex, name::Symbol)\n\nCheck if `ex` contains symbol `name`.\n" function has_symbol(#= none:67 =# @nospecialize(ex), name::Symbol)
            ex isa Symbol && return ex === name
            ex isa Expr || return false
            return any((x->begin
                            has_symbol(x, name)
                        end), ex.args)
        end
    #= none:73 =# Core.@doc "    has_kwfn_constructor(def[, name = struct_name_plain(def)])\n\nCheck if the struct definition contains keyword function constructor of `name`.\nThe constructor name to check by default is the plain constructor which does\nnot infer any type variables and requires user to input all type variables.\nSee also [`struct_name_plain`](@ref).\n" function has_kwfn_constructor(def, name = struct_name_plain(def))
            any(def.constructors) do fn::JLFunction
                isempty(fn.args) && fn.name == name
            end
        end
    #= none:87 =# Core.@doc "    has_plain_constructor(def, name = struct_name_plain(def))\n\nCheck if the struct definition contains the plain constructor of `name`.\nBy default the name is the inferable name [`struct_name_plain`](@ref).\n\n# Example\n\n```julia\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::Int\n    y::N\n\n    Foo{T, N}(x, y) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # true\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo(x, y) = new{typeof(x), typeof(y)}(x, y)\nend\n\nhas_plain_constructor(def) # false\n```\n\nthe arguments must have no type annotations.\n\n```julia\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo{T, N}(x::T, y::N) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # false\n```\n" function has_plain_constructor(def, name = struct_name_plain(def))
            any(def.constructors) do fn::JLFunction
                fn.name == name || return false
                fn.kwargs === nothing || return false
                length(def.fields) == length(fn.args) || return false
                for (f, x) = zip(def.fields, fn.args)
                    f.name === x || return false
                end
                return true
            end
        end
    #= none:140 =# Core.@doc "    is_function(def)\n\nCheck if given object is a function expression.\n" function is_function(#= none:145 =# @nospecialize(def))
            let
                begin
                    var"##cache#319" = nothing
                end
                var"##return#316" = nothing
                var"##318" = def
                if var"##318" isa JLFunction
                    begin
                        var"##return#316" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#317#326")))
                    end
                end
                if var"##318" isa Expr
                    if begin
                                if var"##cache#319" === nothing
                                    var"##cache#319" = Some(((var"##318").head, (var"##318").args))
                                end
                                var"##320" = (var"##cache#319").value
                                var"##320" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##320"[1] == :function && (begin
                                        var"##321" = var"##320"[2]
                                        var"##321" isa AbstractArray
                                    end && length(var"##321") === 2))
                        var"##return#316" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#317#326")))
                    end
                    if begin
                                var"##322" = (var"##cache#319").value
                                var"##322" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##322"[1] == :(=) && (begin
                                        var"##323" = var"##322"[2]
                                        var"##323" isa AbstractArray
                                    end && length(var"##323") === 2))
                        var"##return#316" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#317#326")))
                    end
                    if begin
                                var"##324" = (var"##cache#319").value
                                var"##324" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##324"[1] == :-> && (begin
                                        var"##325" = var"##324"[2]
                                        var"##325" isa AbstractArray
                                    end && length(var"##325") === 2))
                        var"##return#316" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#317#326")))
                    end
                end
                begin
                    var"##return#316" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#317#326")))
                end
                error("matching non-exhaustive, at #= none:146 =#")
                $(Expr(:symboliclabel, Symbol("####final#317#326")))
                var"##return#316"
            end
        end
    #= none:155 =# Core.@doc "    is_kw_function(def)\n\nCheck if a given function definition supports keyword arguments.\n" function is_kw_function(#= none:160 =# @nospecialize(def))
            is_function(def) || return false
            if def isa JLFunction
                return def.kwargs !== nothing
            end
            (_, call, _) = split_function(def)
            let
                begin
                    var"##cache#330" = nothing
                end
                var"##return#327" = nothing
                var"##329" = call
                if var"##329" isa Expr
                    if begin
                                if var"##cache#330" === nothing
                                    var"##cache#330" = Some(((var"##329").head, (var"##329").args))
                                end
                                var"##331" = (var"##cache#330").value
                                var"##331" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##331"[1] == :tuple && (begin
                                        var"##332" = var"##331"[2]
                                        var"##332" isa AbstractArray
                                    end && ((ndims(var"##332") === 1 && length(var"##332") >= 1) && (begin
                                                begin
                                                    var"##cache#334" = nothing
                                                end
                                                var"##333" = var"##332"[1]
                                                var"##333" isa Expr
                                            end && (begin
                                                    if var"##cache#334" === nothing
                                                        var"##cache#334" = Some(((var"##333").head, (var"##333").args))
                                                    end
                                                    var"##335" = (var"##cache#334").value
                                                    var"##335" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##335"[1] == :parameters && (begin
                                                            var"##336" = var"##335"[2]
                                                            var"##336" isa AbstractArray
                                                        end && (ndims(var"##336") === 1 && length(var"##336") >= 0))))))))
                        var"##return#327" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#328#346")))
                    end
                    if begin
                                var"##337" = (var"##cache#330").value
                                var"##337" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##337"[1] == :call && (begin
                                        var"##338" = var"##337"[2]
                                        var"##338" isa AbstractArray
                                    end && ((ndims(var"##338") === 1 && length(var"##338") >= 2) && (begin
                                                begin
                                                    var"##cache#340" = nothing
                                                end
                                                var"##339" = var"##338"[2]
                                                var"##339" isa Expr
                                            end && (begin
                                                    if var"##cache#340" === nothing
                                                        var"##cache#340" = Some(((var"##339").head, (var"##339").args))
                                                    end
                                                    var"##341" = (var"##cache#340").value
                                                    var"##341" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##341"[1] == :parameters && (begin
                                                            var"##342" = var"##341"[2]
                                                            var"##342" isa AbstractArray
                                                        end && (ndims(var"##342") === 1 && length(var"##342") >= 0))))))))
                        var"##return#327" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#328#346")))
                    end
                    if begin
                                var"##343" = (var"##cache#330").value
                                var"##343" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##343"[1] == :block && (begin
                                        var"##344" = var"##343"[2]
                                        var"##344" isa AbstractArray
                                    end && (length(var"##344") === 3 && begin
                                            var"##345" = var"##344"[2]
                                            var"##345" isa LineNumberNode
                                        end)))
                        var"##return#327" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#328#346")))
                    end
                end
                begin
                    var"##return#327" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#328#346")))
                end
                error("matching non-exhaustive, at #= none:168 =#")
                $(Expr(:symboliclabel, Symbol("####final#328#346")))
                var"##return#327"
            end
        end
    #= none:176 =# @deprecate is_kw_fn(def) is_kw_function(def)
    #= none:177 =# @deprecate is_fn(def) is_function(def)
    #= none:179 =# Core.@doc "    is_struct(ex)\n\nCheck if `ex` is a struct expression.\n" function is_struct(#= none:184 =# @nospecialize(ex))
            ex isa Expr || return false
            return ex.head === :struct
        end
    #= none:189 =# Core.@doc "    is_struct_not_kw_struct(ex)\n\nCheck if `ex` is a struct expression excluding keyword struct syntax.\n" function is_struct_not_kw_struct(ex)
            is_struct(ex) || return false
            body = ex.args[3]
            body isa Expr && body.head === :block || return false
            any(is_field_default, body.args) && return false
            return true
        end
    #= none:202 =# Core.@doc "    is_ifelse(ex)\n\nCheck if `ex` is an `if ... elseif ... else ... end` expression.\n" function is_ifelse(#= none:207 =# @nospecialize(ex))
            ex isa Expr || return false
            return ex.head === :if
        end
    #= none:212 =# Core.@doc "    is_for(ex)\n\nCheck if `ex` is a `for` loop expression.\n" function is_for(#= none:217 =# @nospecialize(ex))
            ex isa Expr || return false
            return ex.head === :for
        end
    #= none:222 =# Core.@doc "    is_field(ex)\n\nCheck if `ex` is a valid field expression.\n" function is_field(#= none:227 =# @nospecialize(ex))
            let
                begin
                    var"##cache#350" = nothing
                end
                var"##return#347" = nothing
                var"##349" = ex
                if var"##349" isa Expr
                    if begin
                                if var"##cache#350" === nothing
                                    var"##cache#350" = Some(((var"##349").head, (var"##349").args))
                                end
                                var"##351" = (var"##cache#350").value
                                var"##351" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##351"[1] == :(=) && (begin
                                        var"##352" = var"##351"[2]
                                        var"##352" isa AbstractArray
                                    end && (length(var"##352") === 2 && (begin
                                                begin
                                                    var"##cache#354" = nothing
                                                end
                                                var"##353" = var"##352"[1]
                                                var"##353" isa Expr
                                            end && (begin
                                                    if var"##cache#354" === nothing
                                                        var"##cache#354" = Some(((var"##353").head, (var"##353").args))
                                                    end
                                                    var"##355" = (var"##cache#354").value
                                                    var"##355" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##355"[1] == :(::) && (begin
                                                            var"##356" = var"##355"[2]
                                                            var"##356" isa AbstractArray
                                                        end && (length(var"##356") === 2 && begin
                                                                var"##357" = var"##356"[1]
                                                                var"##358" = var"##356"[2]
                                                                var"##359" = var"##352"[2]
                                                                true
                                                            end))))))))
                        var"##return#347" = let default = var"##359", type = var"##358", name = var"##357"
                                false
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#348#368")))
                    end
                    if begin
                                var"##360" = (var"##cache#350").value
                                var"##360" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##360"[1] == :(=) && (begin
                                        var"##361" = var"##360"[2]
                                        var"##361" isa AbstractArray
                                    end && (length(var"##361") === 2 && (begin
                                                var"##362" = var"##361"[1]
                                                var"##362" isa Symbol
                                            end && begin
                                                var"##363" = var"##361"[2]
                                                true
                                            end))))
                        var"##return#347" = let default = var"##363", name = var"##362"
                                false
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#348#368")))
                    end
                    if begin
                                var"##364" = (var"##cache#350").value
                                var"##364" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##364"[1] == :(::) && (begin
                                        var"##365" = var"##364"[2]
                                        var"##365" isa AbstractArray
                                    end && (length(var"##365") === 2 && begin
                                            var"##366" = var"##365"[1]
                                            var"##367" = var"##365"[2]
                                            true
                                        end)))
                        var"##return#347" = let type = var"##367", name = var"##366"
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#348#368")))
                    end
                end
                if var"##349" isa Symbol
                    begin
                        var"##return#347" = let name = var"##349"
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#348#368")))
                    end
                end
                begin
                    var"##return#347" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#348#368")))
                end
                error("matching non-exhaustive, at #= none:228 =#")
                $(Expr(:symboliclabel, Symbol("####final#348#368")))
                var"##return#347"
            end
        end
    #= none:237 =# Core.@doc "    is_field_default(ex)\n\nCheck if `ex` is a `<field expr> = <default expr>` expression.\n" function is_field_default(#= none:242 =# @nospecialize(ex))
            let
                begin
                    var"##cache#372" = nothing
                end
                var"##return#369" = nothing
                var"##371" = ex
                if var"##371" isa Expr
                    if begin
                                if var"##cache#372" === nothing
                                    var"##cache#372" = Some(((var"##371").head, (var"##371").args))
                                end
                                var"##373" = (var"##cache#372").value
                                var"##373" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##373"[1] == :(=) && (begin
                                        var"##374" = var"##373"[2]
                                        var"##374" isa AbstractArray
                                    end && (length(var"##374") === 2 && (begin
                                                begin
                                                    var"##cache#376" = nothing
                                                end
                                                var"##375" = var"##374"[1]
                                                var"##375" isa Expr
                                            end && (begin
                                                    if var"##cache#376" === nothing
                                                        var"##cache#376" = Some(((var"##375").head, (var"##375").args))
                                                    end
                                                    var"##377" = (var"##cache#376").value
                                                    var"##377" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##377"[1] == :(::) && (begin
                                                            var"##378" = var"##377"[2]
                                                            var"##378" isa AbstractArray
                                                        end && (length(var"##378") === 2 && begin
                                                                var"##379" = var"##378"[1]
                                                                var"##380" = var"##378"[2]
                                                                var"##381" = var"##374"[2]
                                                                true
                                                            end))))))))
                        var"##return#369" = let default = var"##381", type = var"##380", name = var"##379"
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#370#386")))
                    end
                    if begin
                                var"##382" = (var"##cache#372").value
                                var"##382" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##382"[1] == :(=) && (begin
                                        var"##383" = var"##382"[2]
                                        var"##383" isa AbstractArray
                                    end && (length(var"##383") === 2 && (begin
                                                var"##384" = var"##383"[1]
                                                var"##384" isa Symbol
                                            end && begin
                                                var"##385" = var"##383"[2]
                                                true
                                            end))))
                        var"##return#369" = let default = var"##385", name = var"##384"
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#370#386")))
                    end
                end
                begin
                    var"##return#369" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#370#386")))
                end
                error("matching non-exhaustive, at #= none:243 =#")
                $(Expr(:symboliclabel, Symbol("####final#370#386")))
                var"##return#369"
            end
        end
    #= none:250 =# Core.@doc "    is_datatype_expr(ex)\n\nCheck if `ex` is an expression for a concrete `DataType`, e.g\n`where` is not allowed in the expression.\n" function is_datatype_expr(#= none:256 =# @nospecialize(ex))
            let
                begin
                    var"##cache#390" = nothing
                end
                var"##return#387" = nothing
                var"##389" = ex
                if var"##389" isa GlobalRef
                    begin
                        var"##return#387" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#388#404")))
                    end
                end
                if var"##389" isa Expr
                    if begin
                                if var"##cache#390" === nothing
                                    var"##cache#390" = Some(((var"##389").head, (var"##389").args))
                                end
                                var"##391" = (var"##cache#390").value
                                var"##391" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##391"[1] == :curly && (begin
                                        var"##392" = var"##391"[2]
                                        var"##392" isa AbstractArray
                                    end && (length(var"##392") === 2 && (begin
                                                begin
                                                    var"##cache#394" = nothing
                                                end
                                                var"##393" = var"##392"[2]
                                                var"##393" isa Expr
                                            end && (begin
                                                    if var"##cache#394" === nothing
                                                        var"##cache#394" = Some(((var"##393").head, (var"##393").args))
                                                    end
                                                    var"##395" = (var"##cache#394").value
                                                    var"##395" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##395"[1] == :... && (begin
                                                            var"##396" = var"##395"[2]
                                                            var"##396" isa AbstractArray
                                                        end && length(var"##396") === 1)))))))
                        var"##return#387" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#388#404")))
                    end
                    if begin
                                var"##397" = (var"##cache#390").value
                                var"##397" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##397"[1] == :. && (begin
                                        var"##398" = var"##397"[2]
                                        var"##398" isa AbstractArray
                                    end && (length(var"##398") === 2 && (begin
                                                var"##399" = var"##398"[2]
                                                var"##399" isa QuoteNode
                                            end && begin
                                                var"##400" = (var"##399").value
                                                true
                                            end))))
                        var"##return#387" = let b = var"##400"
                                is_datatype_expr(b)
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#388#404")))
                    end
                    if begin
                                var"##401" = (var"##cache#390").value
                                var"##401" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##401"[1] == :curly && (begin
                                        var"##402" = var"##401"[2]
                                        var"##402" isa AbstractArray
                                    end && ((ndims(var"##402") === 1 && length(var"##402") >= 0) && begin
                                            var"##403" = SubArray(var"##402", (1:length(var"##402"),))
                                            true
                                        end)))
                        var"##return#387" = let args = var"##403"
                                all(is_datatype_expr, args)
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#388#404")))
                    end
                end
                if var"##389" isa Symbol
                    begin
                        var"##return#387" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#388#404")))
                    end
                end
                begin
                    var"##return#387" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#388#404")))
                end
                error("matching non-exhaustive, at #= none:257 =#")
                $(Expr(:symboliclabel, Symbol("####final#388#404")))
                var"##return#387"
            end
        end
    #= none:267 =# Core.@doc "    is_matrix_expr(ex)\n\nCheck if `ex` is an expression for a `Matrix`.\n" function is_matrix_expr(#= none:272 =# @nospecialize(ex))
            Meta.isexpr(ex, :hcat) && return true
            if Meta.isexpr(ex, :typed_vcat)
                args = ex.args[2:end]
            elseif Meta.isexpr(ex, :vcat)
                args = ex.args
            else
                return false
            end
            for row = args
                Meta.isexpr(row, :row) || return false
            end
            return true
        end
