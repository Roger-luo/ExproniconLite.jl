
    #= none:1 =# Core.@doc "    is_valid_typevar(typevar)\n\nCheck if the given typevar is a valid typevar.\n\n!!! note\n    This function is based on [this discourse post](https://discourse.julialang.org/t/what-are-valid-type-parameters/471).\n" function is_valid_typevar(typevar)
            let
                true
                var"##return#225" = nothing
                var"##227" = typevar
                if var"##227" isa TypeVar
                    begin
                        var"##return#225" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#226#228")))
                    end
                end
                if var"##227" isa QuoteNode
                    begin
                        var"##return#225" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#226#228")))
                    end
                end
                if var"##227" isa Type
                    begin
                        var"##return#225" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#226#228")))
                    end
                end
                if isbitstype(typeof(typevar))
                    var"##return#225" = let
                            true
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#226#228")))
                end
                if var"##227" isa Tuple
                    var"##return#225" = let
                            all((x->begin
                                        x isa Symbol || isbitstype(typeof(x))
                                    end), typevar)
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#226#228")))
                end
                begin
                    var"##return#225" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#226#228")))
                end
                error("matching non-exhaustive, at #= none:10 =#")
                $(Expr(:symboliclabel, Symbol("####final#226#228")))
                var"##return#225"
            end
        end
    #= none:20 =# Core.@doc "    is_literal(x)\n\nCheck if `x` is a literal value.\n" function is_literal(x)
            !(x isa Expr || (x isa Symbol || x isa GlobalRef))
        end
    #= none:29 =# Core.@doc "    is_tuple(ex)\n\nCheck if `ex` is a tuple expression, i.e. `:((a,b,c))`\n" is_tuple(x) = begin
                Meta.isexpr(x, :tuple)
            end
    #= none:36 =# Core.@doc "    is_splat(ex)\n\nCheck if `ex` is a splat expression, i.e. `:(f(x)...)`\n" is_splat(x) = begin
                Meta.isexpr(x, :...)
            end
    #= none:43 =# Core.@doc "    is_gensym(s)\n\nCheck if `s` is generated by `gensym`.\n\n!!! note\n    Borrowed from [MacroTools](https://github.com/FluxML/MacroTools.jl).\n" is_gensym(s::Symbol) = begin
                occursin("#", string(s))
            end
    is_gensym(s) = begin
            false
        end
    #= none:54 =# Core.@doc "    support_default(f)\n\nCheck if field type `f` supports default value.\n" support_default(f) = begin
                false
            end
    support_default(f::JLKwField) = begin
            true
        end
    #= none:62 =# Core.@doc "    has_symbol(ex, name::Symbol)\n\nCheck if `ex` contains symbol `name`.\n" function has_symbol(#= none:67 =# @nospecialize(ex), name::Symbol)
            ex isa Symbol && return ex === name
            ex isa Expr || return false
            return any((x->begin
                            has_symbol(x, name)
                        end), ex.args)
        end
    #= none:73 =# Core.@doc "    has_kwfn_constructor(def[, name = struct_name_plain(def)])\n\nCheck if the struct definition contains keyword function constructor of `name`.\nThe constructor name to check by default is the plain constructor which does\nnot infer any type variables and requires user to input all type variables.\nSee also [`struct_name_plain`](@ref).\n" function has_kwfn_constructor(def, name = struct_name_plain(def))
            any(def.constructors) do fn::JLFunction
                isempty(fn.args) && fn.name == name
            end
        end
    #= none:87 =# Core.@doc "    has_plain_constructor(def, name = struct_name_plain(def))\n\nCheck if the struct definition contains the plain constructor of `name`.\nBy default the name is the inferable name [`struct_name_plain`](@ref).\n\n# Example\n\n```julia\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::Int\n    y::N\n\n    Foo{T, N}(x, y) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # true\n\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo(x, y) = new{typeof(x), typeof(y)}(x, y)\nend\n\nhas_plain_constructor(def) # false\n```\n\nthe arguments must have no type annotations.\n\n```julia\ndef = @expr JLKwStruct struct Foo{T, N}\n    x::T\n    y::N\n\n    Foo{T, N}(x::T, y::N) where {T, N} = new{T, N}(x, y)\nend\n\nhas_plain_constructor(def) # false\n```\n" function has_plain_constructor(def, name = struct_name_plain(def))
            any(def.constructors) do fn::JLFunction
                fn.name == name || return false
                fn.kwargs === nothing || return false
                length(def.fields) == length(fn.args) || return false
                for (f, x) = zip(def.fields, fn.args)
                    f.name === x || return false
                end
                return true
            end
        end
    #= none:140 =# Core.@doc "    is_function(def)\n\nCheck if given object is a function expression.\n" function is_function(#= none:145 =# @nospecialize(def))
            let
                true
                var"##return#229" = nothing
                var"##231" = def
                if var"##231" isa JLFunction
                    begin
                        var"##return#229" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#230#232")))
                    end
                end
                if var"##231" isa Expr
                    begin
                        var"##return#229" = let
                                (line, doc, expr) = split_doc(def)
                                if !(isnothing(doc))
                                    source = line
                                end
                                split_function_tuple = split_function_nothrow(expr)
                                isnothing(split_function_tuple) && return false
                                (head, call, body) = split_function_tuple
                                split_head_tuple = let
                                        true
                                        var"##return#233" = nothing
                                        var"##235" = head
                                        if var"##235" == :->
                                            var"##return#233" = let
                                                    split_anonymous_function_head_nothrow(call)
                                                end
                                            $(Expr(:symbolicgoto, Symbol("####final#234#236")))
                                        end
                                        begin
                                            var"##return#233" = let h = var"##235"
                                                    split_function_head_nothrow(call)
                                                end
                                            $(Expr(:symbolicgoto, Symbol("####final#234#236")))
                                        end
                                        error("matching non-exhaustive, at #= none:157 =#")
                                        $(Expr(:symboliclabel, Symbol("####final#234#236")))
                                        var"##return#233"
                                    end
                                isnothing(split_head_tuple) && return false
                                (name, args, kw, whereparams, rettype) = split_head_tuple
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#230#232")))
                    end
                end
                begin
                    var"##return#229" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#230#232")))
                end
                error("matching non-exhaustive, at #= none:146 =#")
                $(Expr(:symboliclabel, Symbol("####final#230#232")))
                var"##return#229"
            end
        end
    #= none:170 =# Core.@doc "    is_kw_function(def)\n\nCheck if a given function definition supports keyword arguments.\n" function is_kw_function(#= none:175 =# @nospecialize(def))
            is_function(def) || return false
            if def isa JLFunction
                return def.kwargs !== nothing
            end
            (_, call, _) = split_function(def)
            let
                begin
                    var"##cache#240" = nothing
                end
                var"##return#237" = nothing
                var"##239" = call
                if var"##239" isa Expr
                    if begin
                                if var"##cache#240" === nothing
                                    var"##cache#240" = Some(((var"##239").head, (var"##239").args))
                                end
                                var"##241" = (var"##cache#240").value
                                var"##241" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##241"[1] == :tuple && (begin
                                        var"##242" = var"##241"[2]
                                        var"##242" isa AbstractArray
                                    end && ((ndims(var"##242") === 1 && length(var"##242") >= 1) && (begin
                                                begin
                                                    var"##cache#244" = nothing
                                                end
                                                var"##243" = var"##242"[1]
                                                var"##243" isa Expr
                                            end && (begin
                                                    if var"##cache#244" === nothing
                                                        var"##cache#244" = Some(((var"##243").head, (var"##243").args))
                                                    end
                                                    var"##245" = (var"##cache#244").value
                                                    var"##245" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##245"[1] == :parameters && (begin
                                                            var"##246" = var"##245"[2]
                                                            var"##246" isa AbstractArray
                                                        end && (ndims(var"##246") === 1 && length(var"##246") >= 0))))))))
                        var"##return#237" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#238#256")))
                    end
                    if begin
                                var"##247" = (var"##cache#240").value
                                var"##247" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##247"[1] == :call && (begin
                                        var"##248" = var"##247"[2]
                                        var"##248" isa AbstractArray
                                    end && ((ndims(var"##248") === 1 && length(var"##248") >= 2) && (begin
                                                begin
                                                    var"##cache#250" = nothing
                                                end
                                                var"##249" = var"##248"[2]
                                                var"##249" isa Expr
                                            end && (begin
                                                    if var"##cache#250" === nothing
                                                        var"##cache#250" = Some(((var"##249").head, (var"##249").args))
                                                    end
                                                    var"##251" = (var"##cache#250").value
                                                    var"##251" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##251"[1] == :parameters && (begin
                                                            var"##252" = var"##251"[2]
                                                            var"##252" isa AbstractArray
                                                        end && (ndims(var"##252") === 1 && length(var"##252") >= 0))))))))
                        var"##return#237" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#238#256")))
                    end
                    if begin
                                var"##253" = (var"##cache#240").value
                                var"##253" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##253"[1] == :block && (begin
                                        var"##254" = var"##253"[2]
                                        var"##254" isa AbstractArray
                                    end && (length(var"##254") === 3 && begin
                                            var"##255" = var"##254"[2]
                                            var"##255" isa LineNumberNode
                                        end)))
                        var"##return#237" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#238#256")))
                    end
                end
                begin
                    var"##return#237" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#238#256")))
                end
                error("matching non-exhaustive, at #= none:183 =#")
                $(Expr(:symboliclabel, Symbol("####final#238#256")))
                var"##return#237"
            end
        end
    #= none:191 =# @deprecate is_kw_fn(def) is_kw_function(def)
    #= none:192 =# @deprecate is_fn(def) is_function(def)
    #= none:194 =# Core.@doc "    is_struct(ex)\n\nCheck if `ex` is a struct expression.\n" function is_struct(#= none:199 =# @nospecialize(ex))
            ex isa Expr || return false
            return ex.head === :struct
        end
    #= none:204 =# Core.@doc "    is_struct_not_kw_struct(ex)\n\nCheck if `ex` is a struct expression excluding keyword struct syntax.\n" function is_struct_not_kw_struct(ex)
            is_struct(ex) || return false
            body = ex.args[3]
            body isa Expr && body.head === :block || return false
            any(is_field_default, body.args) && return false
            return true
        end
    #= none:217 =# Core.@doc "    is_ifelse(ex)\n\nCheck if `ex` is an `if ... elseif ... else ... end` expression.\n" function is_ifelse(#= none:222 =# @nospecialize(ex))
            ex isa Expr || return false
            return ex.head === :if
        end
    #= none:227 =# Core.@doc "    is_for(ex)\n\nCheck if `ex` is a `for` loop expression.\n" function is_for(#= none:232 =# @nospecialize(ex))
            ex isa Expr || return false
            return ex.head === :for
        end
    #= none:237 =# Core.@doc "    is_field(ex)\n\nCheck if `ex` is a valid field expression.\n" function is_field(#= none:242 =# @nospecialize(ex))
            let
                begin
                    var"##cache#260" = nothing
                end
                var"##return#257" = nothing
                var"##259" = ex
                if var"##259" isa Expr
                    if begin
                                if var"##cache#260" === nothing
                                    var"##cache#260" = Some(((var"##259").head, (var"##259").args))
                                end
                                var"##261" = (var"##cache#260").value
                                var"##261" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##261"[1] == :(=) && (begin
                                        var"##262" = var"##261"[2]
                                        var"##262" isa AbstractArray
                                    end && (length(var"##262") === 2 && (begin
                                                begin
                                                    var"##cache#264" = nothing
                                                end
                                                var"##263" = var"##262"[1]
                                                var"##263" isa Expr
                                            end && (begin
                                                    if var"##cache#264" === nothing
                                                        var"##cache#264" = Some(((var"##263").head, (var"##263").args))
                                                    end
                                                    var"##265" = (var"##cache#264").value
                                                    var"##265" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##265"[1] == :(::) && (begin
                                                            var"##266" = var"##265"[2]
                                                            var"##266" isa AbstractArray
                                                        end && (length(var"##266") === 2 && begin
                                                                var"##267" = var"##266"[1]
                                                                var"##268" = var"##266"[2]
                                                                var"##269" = var"##262"[2]
                                                                true
                                                            end))))))))
                        var"##return#257" = let default = var"##269", type = var"##268", name = var"##267"
                                false
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#258#278")))
                    end
                    if begin
                                var"##270" = (var"##cache#260").value
                                var"##270" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##270"[1] == :(=) && (begin
                                        var"##271" = var"##270"[2]
                                        var"##271" isa AbstractArray
                                    end && (length(var"##271") === 2 && (begin
                                                var"##272" = var"##271"[1]
                                                var"##272" isa Symbol
                                            end && begin
                                                var"##273" = var"##271"[2]
                                                true
                                            end))))
                        var"##return#257" = let default = var"##273", name = var"##272"
                                false
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#258#278")))
                    end
                    if begin
                                var"##274" = (var"##cache#260").value
                                var"##274" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##274"[1] == :(::) && (begin
                                        var"##275" = var"##274"[2]
                                        var"##275" isa AbstractArray
                                    end && (length(var"##275") === 2 && begin
                                            var"##276" = var"##275"[1]
                                            var"##277" = var"##275"[2]
                                            true
                                        end)))
                        var"##return#257" = let type = var"##277", name = var"##276"
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#258#278")))
                    end
                end
                if var"##259" isa Symbol
                    begin
                        var"##return#257" = let name = var"##259"
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#258#278")))
                    end
                end
                begin
                    var"##return#257" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#258#278")))
                end
                error("matching non-exhaustive, at #= none:243 =#")
                $(Expr(:symboliclabel, Symbol("####final#258#278")))
                var"##return#257"
            end
        end
    #= none:252 =# Core.@doc "    is_field_default(ex)\n\nCheck if `ex` is a `<field expr> = <default expr>` expression.\n" function is_field_default(#= none:257 =# @nospecialize(ex))
            let
                begin
                    var"##cache#282" = nothing
                end
                var"##return#279" = nothing
                var"##281" = ex
                if var"##281" isa Expr
                    if begin
                                if var"##cache#282" === nothing
                                    var"##cache#282" = Some(((var"##281").head, (var"##281").args))
                                end
                                var"##283" = (var"##cache#282").value
                                var"##283" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##283"[1] == :(=) && (begin
                                        var"##284" = var"##283"[2]
                                        var"##284" isa AbstractArray
                                    end && (length(var"##284") === 2 && (begin
                                                begin
                                                    var"##cache#286" = nothing
                                                end
                                                var"##285" = var"##284"[1]
                                                var"##285" isa Expr
                                            end && (begin
                                                    if var"##cache#286" === nothing
                                                        var"##cache#286" = Some(((var"##285").head, (var"##285").args))
                                                    end
                                                    var"##287" = (var"##cache#286").value
                                                    var"##287" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##287"[1] == :(::) && (begin
                                                            var"##288" = var"##287"[2]
                                                            var"##288" isa AbstractArray
                                                        end && (length(var"##288") === 2 && begin
                                                                var"##289" = var"##288"[1]
                                                                var"##290" = var"##288"[2]
                                                                var"##291" = var"##284"[2]
                                                                true
                                                            end))))))))
                        var"##return#279" = let default = var"##291", type = var"##290", name = var"##289"
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#280#296")))
                    end
                    if begin
                                var"##292" = (var"##cache#282").value
                                var"##292" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##292"[1] == :(=) && (begin
                                        var"##293" = var"##292"[2]
                                        var"##293" isa AbstractArray
                                    end && (length(var"##293") === 2 && (begin
                                                var"##294" = var"##293"[1]
                                                var"##294" isa Symbol
                                            end && begin
                                                var"##295" = var"##293"[2]
                                                true
                                            end))))
                        var"##return#279" = let default = var"##295", name = var"##294"
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#280#296")))
                    end
                end
                begin
                    var"##return#279" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#280#296")))
                end
                error("matching non-exhaustive, at #= none:258 =#")
                $(Expr(:symboliclabel, Symbol("####final#280#296")))
                var"##return#279"
            end
        end
    #= none:265 =# Core.@doc "    is_datatype_expr(ex)\n\nCheck if `ex` is an expression for a concrete `DataType`, e.g\n`where` is not allowed in the expression.\n" function is_datatype_expr(#= none:271 =# @nospecialize(ex))
            let
                begin
                    var"##cache#300" = nothing
                end
                var"##return#297" = nothing
                var"##299" = ex
                if var"##299" isa GlobalRef
                    begin
                        var"##return#297" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#298#314")))
                    end
                end
                if var"##299" isa Expr
                    if begin
                                if var"##cache#300" === nothing
                                    var"##cache#300" = Some(((var"##299").head, (var"##299").args))
                                end
                                var"##301" = (var"##cache#300").value
                                var"##301" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##301"[1] == :curly && (begin
                                        var"##302" = var"##301"[2]
                                        var"##302" isa AbstractArray
                                    end && (length(var"##302") === 2 && (begin
                                                begin
                                                    var"##cache#304" = nothing
                                                end
                                                var"##303" = var"##302"[2]
                                                var"##303" isa Expr
                                            end && (begin
                                                    if var"##cache#304" === nothing
                                                        var"##cache#304" = Some(((var"##303").head, (var"##303").args))
                                                    end
                                                    var"##305" = (var"##cache#304").value
                                                    var"##305" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                                                end && (var"##305"[1] == :... && (begin
                                                            var"##306" = var"##305"[2]
                                                            var"##306" isa AbstractArray
                                                        end && length(var"##306") === 1)))))))
                        var"##return#297" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#298#314")))
                    end
                    if begin
                                var"##307" = (var"##cache#300").value
                                var"##307" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##307"[1] == :. && (begin
                                        var"##308" = var"##307"[2]
                                        var"##308" isa AbstractArray
                                    end && (length(var"##308") === 2 && (begin
                                                var"##309" = var"##308"[2]
                                                var"##309" isa QuoteNode
                                            end && begin
                                                var"##310" = (var"##309").value
                                                true
                                            end))))
                        var"##return#297" = let b = var"##310"
                                is_datatype_expr(b)
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#298#314")))
                    end
                    if begin
                                var"##311" = (var"##cache#300").value
                                var"##311" isa (Tuple{Symbol, var2} where var2 <: AbstractArray)
                            end && (var"##311"[1] == :curly && (begin
                                        var"##312" = var"##311"[2]
                                        var"##312" isa AbstractArray
                                    end && ((ndims(var"##312") === 1 && length(var"##312") >= 0) && begin
                                            var"##313" = SubArray(var"##312", (1:length(var"##312"),))
                                            true
                                        end)))
                        var"##return#297" = let args = var"##313"
                                all(is_datatype_expr, args)
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#298#314")))
                    end
                end
                if var"##299" isa Symbol
                    begin
                        var"##return#297" = let
                                true
                            end
                        $(Expr(:symbolicgoto, Symbol("####final#298#314")))
                    end
                end
                begin
                    var"##return#297" = let
                            false
                        end
                    $(Expr(:symbolicgoto, Symbol("####final#298#314")))
                end
                error("matching non-exhaustive, at #= none:272 =#")
                $(Expr(:symboliclabel, Symbol("####final#298#314")))
                var"##return#297"
            end
        end
    #= none:282 =# Core.@doc "    is_matrix_expr(ex)\n\nCheck if `ex` is an expression for a `Matrix`.\n" function is_matrix_expr(#= none:287 =# @nospecialize(ex))
            Meta.isexpr(ex, :hcat) && return true
            if Meta.isexpr(ex, :typed_vcat)
                args = ex.args[2:end]
            elseif Meta.isexpr(ex, :vcat)
                args = ex.args
            else
                return false
            end
            for row = args
                Meta.isexpr(row, :row) || return false
            end
            return true
        end
